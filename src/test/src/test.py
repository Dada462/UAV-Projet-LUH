#!/usr/bin/env python3
import numpy as np
import rospy
from numpy import pi
from controller_tools.rrt_3D.rrt_connect3D import rrt_connect

# if __name__ == '__main__':
#     p = rrt_connect()
#     spheres = [[8,8.0,1.5,5]]
#     obstacles=np.array(spheres)
#     obstacles=np.random.random((1000,4))+np.array([8,8.0,1.5,0])
#     obstacles[:,-1]=1
#     p.env.balls=obstacles
#     p.qinit=p.env.start=(4,4, 2.0)
#     p.qgoal=p.env.goal=(12.0, 16.0, 0.0)
    
#     p.RRT_CONNECT_PLANNER(p.qinit, p.qgoal)
#     print(p.patha,p.pathb)

# class Main():
#     def __init__(self):
#         rospy.init_node('test', anonymous=True)
#         rospy.Subscriber('/robot_state', Float32MultiArray, self.update_state)
#         self.main()


#     def main(self):
#         f = 30
#         rate = rospy.Rate(f)
#         i = 0
#         while not rospy.is_shutdown():
#             i += 1
#             rate.sleep()

#     def update_state(self, data):
#         self.state = np.array([*data.data])


# if __name__ == '__main__':
#     try:
#         C = Main()
#     except rospy.ROSInterruptException:
#         pass

if __name__=='__main__':
    import matplotlib.pyplot as plt
    import numpy as np

    # path=[((0.7972019552538592, 6.092818846737666, 0.46930926323462857), (1.1174578785742217, 6.4767492498945405, 0.4751048745071474)), ((0.45609410463526345, 5.72990030042916, 0.42531422951850756), (0.7972019552538592, 6.092818846737666, 0.46930926323462857)), ((0.32664181784146706, 5.247026914687138, 0.43399747694637203), (0.45609410463526345, 5.72990030042916, 0.42531422951850756)), ((0.0, 4.87, 0.4), (0.32664181784146706, 5.247026914687138, 0.43399747694637203)), ((1.1473354947015448, 6.194781617176104, 0.49975545700054586), (1.1174578785742217, 6.4767492498945405, 0.4751048745071474)), ((1.199823149496118, 5.699433537653997, 0.5430604937506303), (1.1473354947015448, 6.194781617176104, 0.49975545700054586)), ((1.252310804290691, 5.20408545813189, 0.5863655305007147), (1.199823149496118, 5.699433537653997, 0.5430604937506303)), ((1.3047984590852642, 4.708737378609783, 0.6296705672507991), (1.252310804290691, 5.20408545813189, 0.5863655305007147)), ((1.357286113879837, 4.213389299087676, 0.6729756040008834), (1.3047984590852642, 4.708737378609783, 0.6296705672507991)), ((1.4097737686744103, 3.718041219565569, 0.7162806407509679), (1.357286113879837, 4.213389299087676, 0.6729756040008834)), ((1.4622614234689832, 3.222693140043462, 0.7595856775010523), (1.4097737686744103, 3.718041219565569, 0.7162806407509679)), ((1.5147490782635564, 2.727345060521355, 0.8028907142511368), (1.4622614234689832, 3.222693140043462, 0.7595856775010523)), ((1.279272704702464, 2.2899922731006024, 0.7456769324340369), (1.5147490782635564, 2.727345060521355, 0.8028907142511368)), ((1.0822767366978514, 1.8305492607479805, 0.7354442890671364), (1.279272704702464, 2.2899922731006024, 0.7456769324340369)), ((0.5973270473054983, 1.7091650622192611, 0.7449139831382716), (1.0822767366978514, 1.8305492607479805, 0.7354442890671364)), ((0.39275504821831736, 1.2799755283898677, 0.5901669597718029), (0.5973270473054983, 1.7091650622192611, 0.7449139831382716)), ((0.08, 0.89, 0.58), (0.39275504821831736, 1.2799755283898677, 0.5901669597718029))]
    patha=[((0.7972019552538592, 6.092818846737666, 0.46930926323462857), (1.1174578785742217, 6.4767492498945405, 0.4751048745071474)), ((0.45609410463526345, 5.72990030042916, 0.42531422951850756), (0.7972019552538592, 6.092818846737666, 0.46930926323462857)), ((0.32664181784146706, 5.247026914687138, 0.43399747694637203), (0.45609410463526345, 5.72990030042916, 0.42531422951850756)), ((0.0, 4.87, 0.4), (0.32664181784146706, 5.247026914687138, 0.43399747694637203))]
    pathb=[((1.1473354947015448, 6.194781617176104, 0.49975545700054586), (1.1174578785742217, 6.4767492498945405, 0.4751048745071474)), ((1.199823149496118, 5.699433537653997, 0.5430604937506303), (1.1473354947015448, 6.194781617176104, 0.49975545700054586)), ((1.252310804290691, 5.20408545813189, 0.5863655305007147), (1.199823149496118, 5.699433537653997, 0.5430604937506303)), ((1.3047984590852642, 4.708737378609783, 0.6296705672507991), (1.252310804290691, 5.20408545813189, 0.5863655305007147)), ((1.357286113879837, 4.213389299087676, 0.6729756040008834), (1.3047984590852642, 4.708737378609783, 0.6296705672507991)), ((1.4097737686744103, 3.718041219565569, 0.7162806407509679), (1.357286113879837, 4.213389299087676, 0.6729756040008834)), ((1.4622614234689832, 3.222693140043462, 0.7595856775010523), (1.4097737686744103, 3.718041219565569, 0.7162806407509679)), ((1.5147490782635564, 2.727345060521355, 0.8028907142511368), (1.4622614234689832, 3.222693140043462, 0.7595856775010523)), ((1.279272704702464, 2.2899922731006024, 0.7456769324340369), (1.5147490782635564, 2.727345060521355, 0.8028907142511368)), ((1.0822767366978514, 1.8305492607479805, 0.7354442890671364), (1.279272704702464, 2.2899922731006024, 0.7456769324340369)), ((0.5973270473054983, 1.7091650622192611, 0.7449139831382716), (1.0822767366978514, 1.8305492607479805, 0.7354442890671364)), ((0.39275504821831736, 1.2799755283898677, 0.5901669597718029), (0.5973270473054983, 1.7091650622192611, 0.7449139831382716)), ((0.08, 0.89, 0.58), (0.39275504821831736, 1.2799755283898677, 0.5901669597718029))]
    patha=np.array(patha)
    pathb=np.array(pathb)
    
    def rearange_path(self,p):
        # check
        if (p[1:,0,:]==p[:-1,1,:]).all():
            pass # do not change the path
        elif (p[:-1,0,:]==p[1:,1,:]).all():
            print('permuted everything')
            p=p[:,::-1,:]
        else:
            print('something is wrong')
            return p
        p=np.vstack((p[:,0,:],p[-1,1,:]))
        return p
    def connect_paths(self,patha,pathb):
        eps=0.25
        if np.linalg.norm(patha[-1]-pathb[0])<eps:
            # join paths
            connected_path=np.vstack((patha,pathb))
        elif np.linalg.norm(patha[0]-pathb[0])<eps:
            # flip the path
            connected_path=np.vstack((patha[::-1],pathb))
        else:
            print('[ERROR 1] There is a problem, check the path or the threshold')
        
        connected_path
        if np.linalg.norm(connected_path[0]-X)<eps:
            # join paths
            return connected_path
        elif np.linalg.norm(connected_path[-1]-X)<eps:
            # flip the path
            return connected_path[::-1]
        else:
            print('[ERROR 2] There is a problem, check the path or the threshold')

    
    X=np.array([0,0.8,0.45])
    patha=rearange_path(0,patha)
    pathb=rearange_path(0,pathb)
    path=connect_paths(0,patha,pathb)
    plt.plot(*(path[:,:2].T))
    plt.scatter(*X[:2],c='blue')
    

    
    # patha=np.load('patha.npy')
    # pathb=np.load('pathb.npy')
    plt.xlim(-2,3)
    plt.ylim(0,7)
    plt.legend()
    plt.show()
    
    # for p in pathb[:,1,:2]:
    #     plt.scatter(*p,c='red')
        # p0=p[0,:2]
        # p1=p[1,:2]
        # plt.scatter(*p0,c='red')
        # plt.scatter(*p1,c='blue')
        # plt.pause(0.5)
    # plt.scatter(*(patha[-1,1,:2].T),c='blue',s=2)
    # plt.plot(*(patha[:,0,:2].T),c='green')
    # plt.plot(*(patha[-1,:,:2].T),c='green')
    # print(patha[0])
    # plt.plot(*(pathb[:,0,:2].T),c='green')
    # plt.scatter(*(pathb[0,1,:2].T),c='blue',s=25)
   
    # patha1=[]
    # for p in patha:
    #     flipped=np.flip(p,axis=0)
    #     patha1.append(flipped)
    # patha=patha1
    # print(len(patha))
    # path=np.vstack((np.flip(pathb,axis=0),patha))
    # path1=path[:,0,:]
    # path=np.vstack((path1,path[-1,-1,:]))
    # plt.plot(path[:,0],path[:,1],label='before',c='red')


    # from scipy.signal import savgol_filter
    # from scipy.interpolate import interp1d
    # path=path.T
    # s=np.linspace(0,1,len(path[0]))
    # path=interp1d(s,path)
    # s=np.linspace(0,1,50)
    # path=path(s)
    # path[0]=savgol_filter(path[0], window_length=40,polyorder=3)
    # path[1]=savgol_filter(path[1], window_length=40,polyorder=3)
    # path[2]=savgol_filter(path[2], window_length=40,polyorder=3)



    
    # plt.plot(path[0],path[1],label='after',c='blue')
